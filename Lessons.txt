42.txt

Instead of running a for loop over an integer, we can simply use while:

for(i=0;i<n;i++)
{

}

//easy to use
while(n--){

}


#include <bits/stdc++.h> - This is the superset of all the CPP standard libraries and including this in CPP file will help us reduce the time invested in writing multiple header files. However, from an engineeering standpoint we should stay away from  this approach as it adds lot of unwanted files and increases compile time.

2.cpp

//
Vector is similar to array but we can change it's size dynamically ulike array

#include <iostream>
#include<vector>

using namespace std;

int main() {
  //vector<type> name[size];
    vector<int>  test;    //size is optional.
    vector<int>  test[10] //here the size is 10
    test.pushback(2);     //Adding an element(2) to the vector from the back or end
    test.size()           //To access the vector size
    test.at(0)            // Accessing element at index 0

Lessons on Primes:
=================

Any number(n) that have a factor < sqrt(n) will have a factor > sqrt(n). (used in simple sieve and segmented sieve)
This fact is used to prove the Primality of a number in O(sqrt(n)) time.
Same is used in Sieve Of Eratosthenes as well. to reduce the number of iterations.

Generally to handle 10 digit numbers, we should use long long int data type.

Time complexity of Sieve of Eratosthenes
========================================

Suppose n the upper limit, then the required time (T(n)) is equal to:

T(n)=(n/2+n/3+n/5+...)=n∗(1+1/2+1/3+...)

Why n/2, n/3 etc. that is because we do those many iterations after finding every prime.


So the problem reduces to find the sum of the reciprocal of the primes numbers up to n.

This is difficult, but the final result is: O(log(log(n)))
log(log(n)))

So the final complexity is:

T(n)=O(n∗log(log(n)))

Simple Seive is efficient in regards to time, But when it comes to Space this becomes tricky as space required to store the initial bool array is too big. Hence, we have segmented Seive which requires only sqrt(n) space, but similar time complexity as sieve.


Data Type sizes and ranges :

https://www.topcoder.com/community/data-science/data-science-tutorials/representation-of-integers-and-reals-section-1/

The storage size of an int and an unsigned int is platform dependent.
 E.g., on machines using 64-bit registers, ints in g++ will have 64 bits.
 The old Borland C compiler used 16-bit ints.
 It is guaranteed that an int will always have at least 16 bits. Similarly, it is guaranteed that on any system a long will have at least 32 bits.
